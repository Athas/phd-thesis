\chapter{Fusion}
\label{chap:fusion}

This chapter describes the approach taken by the Futhark compiler to
perform loop fusion on SOACs.  Our approach is capable of handling
both \textit{vertical fusion}, where two SOACs are in a
producer-consumer relationship, and \textit{horizontal fusion}, where
two otherwise independent SOACs take the same array as input.  As all
other optimisations in the Futhark compiler, the approach is based on
a syntactic rewriting of abstract syntax trees.

The core of the technique has been previously described in my master's
thesis~\cite{henriksen2014exploiting}.  The current thesis makes three
new contributions:

\begin{enumerate}
\item A simple technique for integrating horizontal fusion in the
  existing framework.  The previously published work did not support
  horizontal fusion at all.
\item Vertical fusion of \lstinline{map} into \lstinline{scan} and
  \lstinline{map} into \lstinline{scatter}.
\item Fusion rules for the streaming SOACs: \lstinline{stream_red},
  \lstinline{stream_map}, and \lstinline{stream_red}.
\end{enumerate}

However, before we can move on to the new contributions, we must
establish the basic fusion algorithm.

The rules by which we combine SOACs through fusion is called the
\textit{fusion algebra}.  The fusion algebra used by the Futhark
compiler has as its central goals to never duplicate computation, and
never reduce available parallelism.  This ensures that the asymptotics
of the program under optimisation are not affected.  Instead, the goal
of fusion is to eliminate the overhead of storing intermediate results
in memory.

Most fusion algorithms in the literature are unable to handle fusion
across \lstinline{zip}/\lstinline{unzip}, and more generally the case
where the output of a producer is used by several consumers.  The
algorithm presented in this chapter is capable of fusing such cases
whenever possible without duplicating computation, as demonstrated on
\cref{fig:fusion-multiple-consumers}.  The linchpin of this capability
is our choice of internal representation, in which arrays of tuples
(and therefore \lstinline{zip}/\lstinline{unzip}) does not occur.

\begin{figure}
\begin{subfigure}[t]{0.4\textwidth}
\begin{lstlisting}
let @b@ = map (+1) a
let c = map (+2) @b@
let d = map (+3) @b@
in map (+) c d
\end{lstlisting}
\caption{Unfused}
\end{subfigure}%
\hspace{.1\textwidth}
\begin{subfigure}[t]{0.4\textwidth}
\begin{lstlisting}
map (\x ->
      let c = x + 2
      let d = x + 3
      in c + d)
    a
\end{lstlisting}
\caption{Fused}
\end{subfigure}%
\caption{Fusing multiple consumers without duplicating computation}
\label{fig:fusion-multiple-consumers}
\end{figure}

This chapter covers two main themes: \Cref{sec:fusion-algorithm}
describes our aggressive fusion algorithm, in particular when a
producer result may be used by multiple consumers, without duplicating
computation.  \Cref{sec:fusionalgebra} describes the rewrite rules
used to fuse two SOACs.

\section{New SOACs}
\label{sec:fusion-in-futhark}

The SOACs we have used so far are a close match to the SOACs of the
source Futhark language.  However, they do not permit a fusion algebra
as rich as we desire.  Using the previously shown SOACs, there is not
even a way to fuse a composition of \lstinline{map} and
\lstinline{reduce}.  This section will introduce a new set of SOACs
that, while perhaps not as aesthetically pleasing and orthogonal as
those in the source languages, have two important qualities:

\begin{enumerate}
\item Their fusion properties are much more powerful, permitting for
  example both vertical and horizontal of \lstinline{map} into
  \lstinline{reduce} or \lstinline{scan}.
\item They permit an efficient mapping to parallel code.  This
  requirement prevents us from defining overly complicated SOACS that
  fuse with everything, but no longer have parallel semantics.  This
  issue is examined in more depth in \cref{chap:kernel-extraction}.
\end{enumerate}

The new SOACs are shown on \Cref{fig:newSoacType}.  An individual
description now follows, which also shows how instances of the
previous SOACs are mapped to the new ones.

\begin{description}
\item[{\kw{map}}] is unchanged from before.
\item[{\kw{scatter}}] now takes a functional argument, which maps $n$
  input arrays to $m$ pairs of indexes and values, which are written
  to the $m$ destination arrays, if the indexes are in bounds.
  What we previously wrote as\\
  \centerline{\lstinline{scatter dest is vs}}\\
  we would now write as\\
  \centerline{\lstinline{scatter (\i v -> (i,v)) (dest) is vs}} The
  \lstinline{dest} is in parentheses to distinguish the destination
  arrays from the input arrays.
\item[\kw{redomap}] is a composition of \kw{map} and \kw{reduce} that
  permits a particularly efficient implementation.  \fixme{refer to
    formalism.}  The \kw{redomap} fold operator returns $m+l$ values.
  The first $m$ are reduced with the reduction operator, while the
  remaining $l$ are simply returned as an array in the final result.
  We shall soon see how this enables horizontal fusion.  The
  relationship between source-language \kw{reduce} and \kw{redomap} is
  by the
  following equivalence:\\
  \centerline{\lstinline{reduce f x a} = \lstinline{redomap f f x a}}
\item[\kw{scanomap}] is similar to \kw{redomap}, but performs a scan
  instead of a reduction.  The following equivalence holds:\\
  \centerline{\lstinline{scan f x a} = \lstinline{scan f f x a}}
\item[\kw{stream\_par}] functions as a unification of the
  \kw{stream\_map} and \kw{stream\_red} of the source language.  As
  with \kw{redomap}, the chunk operator returns $m+l$ values, of which
  the first $m$ take part in reduction, and the latter $l$ are simply
  returned.  One restriction is that the latter $l$ values much all be
  arrays of size $x$, where $x$ is the size of the input chunk given
  to the operator.
\item[\kw{stream\_seq}] is a SOAC used to fuse otherwise infusible
  cases, without losing potential parallelism, by performing what is
  semantically a fold over chunks of the input array.  The chunk
  operator takes the current values of the accumulator, as well as
  chunks of the $n$ input arrays, and returns new values for the
  accumulator.  We can recover all parallelism in the chunk operator
  by applying it to ``chunks'' containing the full input arrays, or
  fully sequentialise by adding an outer sequential loop and setting
  the chunk size to 1.  This aids in efficient sequentialisation.
\end{description}

We exclude \kw{filter} from our discussion of fusion.  While
\kw{filter} does have useful fusion properties (in particular with
\kw{reduce}/\kw{redomap}), the current implementation in the Futhark
compiler implements \kw{filter} by a decomposition into \kw{scan} and
\kw{scatter}.

\begin{figure}[hbt]
\begin{tabular}{lcl}
\emph{op} & & \textrm{TySch}(\emph{op}) \\ \hline
  {\lstinline!map!} & : & $\forall d \bar{\alpha}^{(n)}\bar{\beta}^{(m)}. (\alpha_1 \rightarrow \cdots \rightarrow \alpha_n \rightarrow (\bar{\beta}^{(m)}))$ \\
          & & ~~~~~~~~~~~~~~~~~ $\rightarrow [d]\alpha_1 \rightarrow \cdots \rightarrow [d]\alpha_n$ \\
          & & ~~~~~~~~~~~~~~~~~ $\rightarrow ([d]\beta_1,\ldots,[d]\beta_m)$ \\
  {\lstinline!scatter!} & : & $\forall d \nseq{x}{m} \bar{\alpha}^{(n)}\bar{\beta}^{(m)}.$\\
          & & ~~~~~~~~~~~~~~ $(\alpha_1 \rightarrow \ldots \rightarrow \alpha_n \rightarrow (\texttt{i32}, \beta_{1}, \ldots, \texttt{i32}, \beta_{m}))$\\
          & & ~~~~~~~~~~ $\rightarrow ([x_{1}]\beta_1, \ldots, [x_{m}]\beta_m)$\\
          & & ~~~~~~~~~~ $\rightarrow [d]\alpha_1 \rightarrow \cdots \rightarrow [d]\alpha_n$\\
          & & ~~~~~~~~~~ $\rightarrow ([x_{1}]\beta_1, \ldots, [x_{m}]\beta_n)$\\
  {\lstinline!redomap!} & : & $\forall d \bar{\alpha}^{(m)}\bar{\beta}^{(n)}\nseq{\gamma}{l}.$\\
          & & ~~~~~~~~~~~~~~ $(\alpha_1 \rightarrow \cdots \rightarrow \alpha_m \rightarrow \alpha_1 \rightarrow \cdots \rightarrow \alpha_m \rightarrow (\bar{\alpha}^{(m)}))$\\
          & & ~~~~~~~~~~ $\rightarrow (\alpha_1 \rightarrow \cdots \rightarrow \alpha_m \rightarrow \beta_1 \rightarrow \cdots \rightarrow \beta_n \rightarrow (\bar{\alpha}^{(m)}, \bar{\gamma}^{(l)}))$ \\
          & & ~~~~~~~~~~ $\rightarrow (\alpha_1, \cdots, \alpha_m)$\\
          & & ~~~~~~~~~~ $\rightarrow [d]\beta_1 \rightarrow \cdots \rightarrow [d]\beta_n$\\
          & & ~~~~~~~~~~ $\rightarrow (\alpha_1,\ldots,\alpha_m,[d]\gamma_{1},\ldots,[d]\gamma_{l})$ \\
  {\lstinline!scanomap!} & : & $\forall d \bar{\alpha}^{(m)}\bar{\beta}^{(n)}\nseq{\gamma}{l}.$\\
          & & ~~~~~~~~~~~~~~ $(\alpha_1 \rightarrow \cdots \rightarrow \alpha_m \rightarrow \alpha_1 \rightarrow \cdots \rightarrow \alpha_m \rightarrow (\bar{\alpha}^{(m)}))$\\
          & & ~~~~~~~~~~ $\rightarrow (\alpha_1 \rightarrow \cdots \rightarrow \alpha_m \rightarrow \beta_1 \rightarrow \cdots \rightarrow \beta_n \rightarrow (\bar{\alpha}^{(m)}, \bar{\gamma}^{(l)}))$ \\
          & & ~~~~~~~~~~ $\rightarrow (\alpha_1, \cdots, \alpha_m)$\\
          & & ~~~~~~~~~~ $\rightarrow [d]\beta_1 \rightarrow \cdots \rightarrow [d]\beta_n$\\
          & & ~~~~~~~~~~ $\rightarrow ([d]\alpha_1,\ldots,[d]\alpha_m,[d]\gamma_{1},\ldots,[d]\gamma_{l})$ \\
  {\lstinline!stream_par!} & : & $\forall d x \bar{\alpha}^{(m)}\bar{\beta}^{(n)}\nseq{\gamma}{l}.$\\
          & & ~~~~~~~~~~~~~~ $(\alpha_1 \rightarrow \cdots \rightarrow \alpha_m \rightarrow \alpha_1 \rightarrow \cdots \rightarrow \alpha_m \rightarrow (\bar{\alpha}^{(m)}))$\\
          & & ~~~~~~~~~~ $\rightarrow ((x: \texttt{i32}) \rightarrow [x]\beta_1 \rightarrow \cdots \rightarrow [x]\beta_n \rightarrow (\bar{\alpha}^{(m)}, \nseq{[x]\gamma}{l}))$ \\
          & & ~~~~~~~~~~ $\rightarrow [d]\beta_1 \rightarrow \cdots \rightarrow [d]\beta_n$\\
          & & ~~~~~~~~~~ $\rightarrow (\alpha_1,\ldots,\alpha_m,[d]\gamma_{1},\ldots,[d]\gamma_{l})$ \\
  {\lstinline!stream_seq!} & : & $\forall d x \bar{\alpha}^{(m)}\bar{\beta}^{(n)}\nseq{\gamma}{l}.$\\
          & & ~~~~~~~~~~ $\rightarrow ((x: \texttt{i32})$ \\
          & & ~~~~~~~~~~~~~~~ $\rightarrow \alpha_1 \rightarrow \cdots \rightarrow \alpha_m$ \\
          & & ~~~~~~~~~~~~~~~ $\rightarrow [x]\alpha_1 \rightarrow \cdots \rightarrow [x]\alpha_m$ \\
          & & ~~~~~~~~~~~~~~~ $\rightarrow (\bar{\beta}^{(m)}, \nseq{[x]\gamma}{l}))$ \\
          & & ~~~~~~~~~~ $\rightarrow (\alpha_1, \ldots, \alpha_m)$\\
          & & ~~~~~~~~~~ $\rightarrow [d]\beta_1 \rightarrow \cdots \rightarrow [d]\beta_n$\\
          & & ~~~~~~~~~~ $\rightarrow (\alpha_1,\ldots,\alpha_m)$ \\

\end{tabular}
\caption{Extended SOACs used for fusion and later stages of the compiler.}
\label{fig:newSoacType}
\end{figure}

\section{The Overall Fusion Algorithm}

\subsection{Invalid fusion}
\label{sec:invalidfusion}

We must be careful not to violate the uniqueness rules when performing
fusion.  For example, consider the following program.

\begin{lstlisting}
let b = map f a)
let c = a with [i] <- x
in map g b
\end{lstlisting}

Without the constraints imposed upon us by the semantics of in-place
modification, we could fuse to the following program.

\begin{lstlisting}[mathescape]
let c = a with [i] <- x
in map (g \(\circ\) f) a
\end{lstlisting}

However, this results in a violation of Uniqueness Rule 1, and the
resulting program is thus invalid.  In general, we must track the
possible execution paths from the producer-SOAC to the consumer-SOAC,
and only fuse if none of the inputs of the producer have been consumed
(in the uniqueness type sense of the word) by a \lstinline{let-with} or
function call on any possible execution paths.  This is easier than it
may appear at first glance, as the fusion algorithm will only fuse
when the consumer is within the lexical scope of the producer anyway.

\subsection{When to fuse}
\label{sec:whentofuse}

Even when fusion is possible, it may not be beneficial, and may be
harmful to overall performance in the following cases.

\begin{description}[style=nextline]
\item[Computation may be duplicated.]

In the program
\begin{lstlisting}
let x = map f a
let y = map g x
let z = map z x
in (y,z)
\end{lstlisting}
fusing the \texttt{x}-producer into the two consumers will double the
number of calls to the function \texttt{f}, which might be expensive.
The implementation in the Futhark compiler will currently only fuse if
absolutely no computation is duplicated, although this is likely too
conservative.  Duplicating cheap work, for example functions that use
only primitive operations on scalars, is probably not harmful to
overall performance, although we have not investigated this fully.  In
\cref{sec:inlining-indexing}, we present a transformation that, in
some cases, duplicates computation in order to enhance fusibility.

In general, in the context of GPU, the tradeoff between duplicating
computation and increasing communication is not an easy problem to
solve.  Accessing global memory can be more than a hundred times
slower than accessing local (register) memory, hence duplicating
computation may in some cases be preferable.

\item[Can reduce memory locality.]

  Consider a simple case of fusing
  \texttt{(map~$f$)~$\circ$~(map~$g$)}.  When $g$ is executed for an
  element of the input array, neighboring elements will be put into
  the cache, making them faster to access.  This exhibits good data
  locality.  In contrast, the composed function $f~\circ~g$ will
  perform more work after accessing a given input element, increasing
  the risk that the input array may be evicted from the cache before
  the next element is to be used.  On GPUs, there is the added risk of
  the kernel function exercising additional register pressure, which
  may reduce hardware occupancy (thus reducing latency hiding) by
  having fewer computational cores active.  In this case, it may be
  better to execute each of the two \texttt{map}s as separate kernels.
\end{description}

\newpage
\section{Fusion Rules}

\subsection{Vertical Fusion}

The rules describe the fusion of two SOACs with associated patterns,
termed $A$ and $B$, where $A$ produces some arrays that are inputs to
$B$.  Syntactically, we write the SOACs as a \kw{let}-binding without
the \kw{in} part, as $\kw{let}~p~=~e$.  This is important because
fusion not only rewrites the SOAC itself, but also the pattern to
which it is bound.  After fusion, SOAC $A$ is removed from the
program, and therefore soac $C$ must bind the same names as $A$ and
$B$.  It is likely that some of these names will be dead after fusion,
but they will be removed by subsequent simplification, not by the
fusion algorithm itself.

For simplicity, we will assume that the inputs to $B$ have been
arranged such that those arrays as are produced by $A$ come first.  We
commit some abuse of notation when describing the composition of the
lambda functions, as we permit ourselves to invoke lambda operands as
if they were functions.  This is not strictly permitted by the grammar
we use for the core language, but it avoids a significant amount of
tedious bookkeeping in the rules.

\begin{description}
\item[\kw{map}-\kw{map}]\hfill\\
  SOAC $A$:
  \[
    \kw{let}~\seq{ys_{m}}~\seq{ys_{s}}~=~\kw{map}~f~\seq{xs_{A}}
  \]
  SOAC $B$:
  \[
    \kw{let}~\seq{zs}~=~\kw{map}~g~\seq{ys_{m}}~\seq{xs_{B}}
  \]
  Fuses to SOAC $C$:
  \[
    \kw{let}~\seq{zs}~\seq{ys_{m}}~\seq{ys_{s}}~=~\kw{map}~h~\seq{xs_{A}}~\seq{xs_{B}}
  \]
  where
  \begin{align*}
    h =~& \fn \seq{x}~\seq{y} \rightarrow \\
      & \quad \kw{let}~\seq{y_{m}}~\seq{y_{s}} = f~\seq{x} \\
      & \quad \kw{let}~\seq{z} = g~\seq{y_{m}} \\
      & \quad \kw{in}~(\seq{z}, \seq{y_{m}}, \seq{y_{s}})
  \end{align*}

\item[\kw{map}-\kw{redomap}]\hfill\\
  SOAC $A$:
  \[
    \kw{let}~\seq{ys_{m}}~\seq{ys_{s}}~=~\kw{map}~f~\seq{xs_{A}}
  \]
  SOAC $B$:
  \[
    \kw{let}~\seq{zs}~=~\kw{redomap}~\oplus~g~(\seq{v})~\seq{ys_{m}}~\seq{xs_{B}}
  \]
  Fuses to SOAC $C$:
  \[
    \kw{let}~\seq{zs}~\seq{ys_{m}}~\seq{ys_{s}}~=~\kw{redomap}~\oplus~h~(\seq{v})~\seq{xs_{A}}~\seq{xs_{B}}
  \]
  where
  \begin{align*}
    h =~& \fn \seq{a}~\seq{x}~\seq{y} \rightarrow \\
      & \quad \kw{let}~\seq{y_{m}}~\seq{y_{s}} = f~\seq{x} \\
      & \quad \kw{let}~\seq{z} = g~\seq{a}~\seq{y_{m}} \\
      & \quad \kw{in}~(\seq{z}, \seq{y_{m}}, \seq{y_{s}})
  \end{align*}

\item[\kw{map}-\kw{scanomap}]\hfill\\

  Similar to \kw{map}-\kw{redomap}.

\item[\kw{map}-\kw{scatter}]\hfill\\

  SOAC $A$:
  \[
    \kw{let}~\seq{ys}~=~\kw{map}~f~\seq{xs_{A}}
  \]
  SOAC $B$:
  \[
    \kw{let}~\seq{zs}~=~\kw{scatter}~g~(\seq{vs})~\seq{ys}~\seq{xs_{B}}
  \]
  Fuses to SOAC $C$:
  \[
    \kw{let}~\seq{zs}~=~\kw{scatter}~h~(\seq{vs})~\seq{xs_{A}}~\seq{xs_{B}}
  \]
  where
  \begin{align*}
    h =~& \fn \seq{x}~\seq{y} \rightarrow \\
      & \quad \kw{let}~\seq{y}~ = f~\seq{x} \\
      & \quad \kw{let}~\seq{z} = g~\seq{y} \\
      & \quad \kw{in}~\seq{z}
  \end{align*}

  In contrast to other fusion rules, all outputs of SOAC $A$ must be
  used by SOAC $B$.  In the future, it is likely that \kw{scatter}
  will gain map-out results, like \kw{redomap}, to enable greater
  fusibility.

\item[\kw{redomap}-\kw{redomap}]\hfill\\

  SOAC $A$:
  \[
    \kw{let}~\seq{y_{r}}~\seq{ys_{m}}~\seq{ys_{s}}~=~\kw{redomap}~\oplus~f~(\seq{v_{A}})~\seq{xs_{A}}
  \]
  SOAC $B$:
  \[
    \kw{let}~\seq{z_{r}}~\seq{zs_{s}}~=~\kw{redomap}~\otimes~g~(\seq{v_{B}})~\seq{ys_{m}}~\seq{xs_{B}}
  \]
  Fuses to SOAC $C$:
  \[
    \kw{let}~\seq{z_{r}}~\seq{y_{r}}~\seq{zs_{s}}~\seq{ys_{m}}~\seq{ys_{s}}~=~\kw{redomap}~\odot~h~(\seq{v_{A}},\seq{v_{B}})~\seq{xs_{A}}~\seq{xs_{B}}
  \]

  \begin{align*}
    h =~& \fn \seq{a_{A}} \seq{a_{B}} \seq{x}~\seq{y} \rightarrow \\
      & \quad \kw{let}~\seq{c_{A}}~\seq{y_{m}}~\seq{y_{s}}~ = f~\seq{a_{A}}~\seq{x} \\
      & \quad \kw{let}~\seq{c_{B}}~\seq{z} = g~\seq{a_{B}}~\seq{y_{m}} \\
        & \quad \kw{in}~(\seq{c_{A}},\seq{c_{B}},\seq{z},\seq{y_{m}},\seq{y_{s}}) \\
    \odot =~& \fn \seq{a_{A}}~\seq{a_{B}}~\seq{b_{A}}~\seq{b_{B}} \rightarrow \\
        & \quad \kw{let}~\seq{c_{A}} = \oplus~\seq{a_{A}}~\seq{b_{A}} \\
        & \quad \kw{let}~\seq{c_{B}} = \otimes~\seq{a_{B}}~\seq{b_{B}} \\
        & \quad \kw{in}~(\seq{c_{A}}, \seq{c_{B}})
  \end{align*}

\item[\kw{redomap}-\kw{map}]\hfill\\

  Similar to \kw{map}-\kw{redomap}.

\item[\kw{scanomap}-\kw{scanomap}]\hfill\\

  Similar to \kw{redomap}-\kw{scanomap}.

\item[\kw{scanomap}-\kw{map}]\hfill\\

  Similar to \kw{redomap}-\kw{map}.

\item[\kw{stream\_par}-\kw{stream\_par}]\hfill\\

  SOAC $A$:
  \[
    \kw{let}~\seq{y_{r}}~\seq{ys_{m}}~\seq{ys_{s}}~=~\kw{stream\_par}~\oplus~f~\seq{xs_{A}}
  \]
  SOAC $B$:
  \[
    \kw{let}~\seq{z_{r}}~\seq{zs}~=~\kw{stream\_par}~\otimes~g~\seq{ys_{m}}~\seq{xs_{B}}
  \]
  Fuses to SOAC $C$:
  \[
    \kw{let}~\seq{z_{r}}~\seq{y_{r}}~\seq{zs}~\seq{ys_{m}}~\seq{ys_{s}}~=~\kw{stream\_par}~\odot~h~\seq{xs_{A}}~\seq{xs_{B}}
  \]

  \begin{align*}
    h =~& \fn~c~\seq{xs'_{A}}~\seq{xs'_{B}} \rightarrow \\
        & \quad \kw{let}~\seq{y_{A}}~\seq{ys'_{m}}~\seq{ys'_{s}}~ = f~c~\seq{xs'_{A}} \\
        & \quad \kw{let}~\seq{z_{B}}~\seq{zs'} = g~c~\seq{ys'_{m}}~\seq{xs'_{B}} \\
        & \quad \kw{in}~(\seq{z_{B}},\seq{y_{A}},\seq{zs'},\seq{ys'_{m}},\seq{ys'_{s}}) \\
    \odot =~& \fn \seq{a_{A}}~\seq{a_{B}}~\seq{b_{A}}~\seq{b_{B}} \rightarrow \\
        & \quad \kw{let}~\seq{c_{A}} = \oplus~\seq{a_{A}}~\seq{b_{A}} \\
        & \quad \kw{let}~\seq{c_{B}} = \otimes~\seq{a_{B}}~\seq{b_{B}} \\
        & \quad \kw{in}~(\seq{c_{A}}, \seq{c_{B}})
  \end{align*}

\item[\kw{stream\_seq}-\kw{stream\_seq}]\hfill\\

  SOAC $A$:
  \[
    \kw{let}~\seq{y_{r}}~\seq{ys_{m}}~\seq{ys_{s}} = \kw{stream\_seq}~f~(\seq{v}_{A})~\seq{xs_{A}}
  \]
  SOAC $B$:
  \[
    \kw{let}~\seq{z_{r}}~\seq{zs} = \kw{stream\_seq}~g~\seq{ys_{m}}~(\seq{v}_{B})~\seq{xs_{B}}
  \]
  Fuses to SOAC $B$:
  \[
    \kw{let}~\seq{y_{r}}~\seq{z_{r}}~\seq{zs}~\seq{ys_{m}}~\seq{ys_{s}} = \kw{stream\_seq}~h~\seq{ys_{m}}~(\seq{v}_{B})~\seq{xs_{B}}
  \]

  \begin{align*}
    h =~& \fn~c~\seq{a_{A}}~\seq{a_{B}}~\seq{xs'_{A}}~\seq{xs'_{B}} \rightarrow \\
        & \quad \kw{let}~\seq{y_{A}}~\seq{ys'_{m}}~\seq{ys'_{s}}~ = f~c~\seq{a_{A}}~\seq{xs'_{A}} \\
        & \quad \kw{let}~\seq{z_{B}}~\seq{zs'} = g~c~\seq{a_{B}}~\seq{ys'_{m}}~\seq{xs'_{B}} \\
        & \quad \kw{in}~(\seq{z_{B}},\seq{y_{A}},\seq{zs'},\seq{ys'_{m}},\seq{ys'_{s}}) \\
  \end{align*}

\end{description}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "thesis"
%%% End:
