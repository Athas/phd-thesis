\chapter{Introduction}

TODO:

\begin{itemize}
\item scope and philosophical level of how our approach is placed compared to imperative approaches

\item show the vision

\item futhark source language examples and introduction

\item show how techniques from imperative compilers become easier in a functional setting

\item talk about all kinds of promising techniques, followed by a compiler that can actually do some of them.
\end{itemize}

This thesis describes the design and implementation of
\textit{Futhark}, a data parallel functional programming language.
Futhark is a small programming language that is superficially similar
to known functional languages such as OCaml and Haskell, but with
restrictions and extensions meant to permit compilation into efficient
parallel code.  While this thesis contains techniques that could be
applied in other settings, Futhark has been the overarching context
for my work.  We demonstrate the applicability and efficiency of the
techniques by their application in the Futhark compiler, and the
performance of the resulting code.  Apart from serving as a vehicle
for compiler research, Futhark is also a programming language that is
useful in practice for high-performance parallel programming.

The remainder of this introductory chapter introduces the challenges
posed by modern high-performance parallel computers.  We will discuss
that while conventional imperative languages once benefited greatly
from their relatively close similarity to the hardware, the divide
behind their conceptual model and the realities of hardware is now
ever widening.  We will show the advantages of a high-level explicitly
parallel programming model, both for expressing parallel algorithms,
as well as for compilation to efficient low-level code.  We will
discuss how techniques considered \textit{heroic effort} in a compiler
for an imperative language become tractable when applied in the
functional setting.

\Cref{chap:calculus} introduces a formal array calculus that
serves as inspiration for Futhark.  Various rewrite rules are shown
and justified.  \Cref{chap:hardware} discusses a simplified but
performance-faithful model of contemporary GPU hardware, and shows
how the primitive combinators of the previous chapter can be mapped
efficiently to low-level code.

The second part of the thesis discusses various analyses,
transformations, and optimisations carried out by the Futhark
compiler.  These constitute my main contributions.
\Cref{chap:size-analysis} shows a technique for array shape
analysis based on slicing and existential types (previously published
at FHPC 2014~\cite{henriksen2014size}).  \Cref{chap:fusion}
presents the fusion algorithm employed by the fusion compiler ---
parts have been published in FHPC 2013~\cite{henriksen2013t2}, my
master's thesis~\cite{henriksen2014exploiting}, FHPC
2016~\cite{Futhark:redomap}, and PLDI
2017~\cite{henriksen2017futhark}.
\Cref{chap:kernel-extraction} shows an algorithm that uses
primarily loop distribution to transforming regular nested parallelism
into flat parallelism.  The main novelty is that information (such as
access patterns) is not destroyed to the degree seen in previous
techniques.  \Cref{chap:tiling} shows an implementation of
automatic \textit{loop tiling} that exploits just this information.
These two chapters are based on work previously published at PLDI
2017~\cite{henriksen2017futhark}.
\Cref{chap:empirical-validation} contains a performance
analysis of Futhark on more than a dozen established benchmarks.
Finally, \cref{chap:interoperability} discusses how to invoke
Futhark code from programs written in other languages, with Python
used as the case study.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "thesis"
%%% End:
